#
msgid ""
msgstr ""
"Project-Id-Version: Python Module of the Week 2.1.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2015-10-06 13:35-0300\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../PyMOTW/contextlib/index.rst:3
msgid "contextlib -- Context manager utilities"
msgstr ""

#: ../../PyMOTW/contextlib/index.rst:8
msgid "Utilities for creating and working with context managers."
msgstr ""

#: ../../PyMOTW/contextlib/index.rst:9
msgid "2.5 and later"
msgstr ""

#: ../../PyMOTW/contextlib/index.rst:11
msgid ""
"The :mod:`contextlib` module contains utilities for working with context "
"managers and the :command:`with` statement."
msgstr ""

#: ../../PyMOTW/contextlib/index.rst:15
msgid ""
"Context managers are tied to the :command:`with` statement. Since "
":command:`with` is officially part of Python 2.6, you have to import it from"
" :mod:`__future__` before using contextlib in Python 2.5."
msgstr ""

#: ../../PyMOTW/contextlib/index.rst:20
msgid "Context Manager API"
msgstr ""

#: ../../PyMOTW/contextlib/index.rst:22
msgid ""
"A *context manager* is responsible for a resource within a code block, "
"possibly creating it when the block is entered and then cleaning it up after"
" the block is exited.  For example, files support the context manager API to"
" make it easy to ensure they are closed after all reading or writing is "
"done."
msgstr ""

#: ../../PyMOTW/contextlib/index.rst:32
msgid ""
"A context manager is enabled by the :command:`with` statement, and the API "
"involves two methods.  The :func:`__enter__` method is run when execution "
"flow enters the code block inside the :command:`with`.  It returns an object"
" to be used within the context.  When execution flow leaves the "
":command:`with` block, the :func:`__exit__` method of the context manager is"
" called to clean up any resources being used."
msgstr ""

#: ../../PyMOTW/contextlib/index.rst:43
msgid ""
"Combining a context manager and the :command:`with` statement is a more "
"compact way of writing a ``try:finally`` block, since the context manager's "
":func:`__exit__` method is always called, even if an exception is raised."
msgstr ""

#: ../../PyMOTW/contextlib/index.rst:63
msgid ""
":func:`__enter__` can return any object to be associated with a name "
"specified in the :command:`as` clause of the :command:`with` statement.  In "
"this example, the :class:`Context` returns an object that uses the open "
"context."
msgstr ""

#: ../../PyMOTW/contextlib/index.rst:72
msgid ""
"It can be a little confusing, but the value associated with the variable "
":data:`c` is the object returned by :func:`__enter__` and *not* the "
":class:`Context` instance created in the :command:`with` statement."
msgstr ""

#: ../../PyMOTW/contextlib/index.rst:94
msgid ""
"The :func:`__exit__` method receives arguments containing details of any "
"exception raised in the :command:`with` block."
msgstr ""

#: ../../PyMOTW/contextlib/index.rst:101
msgid ""
"If the context manager can handle the exception, :func:`__exit__` should "
"return a true value to indicate that the exception does not need to be "
"propagated.  Returning false causes the exception to be re-raised after "
":func:`__exit__` returns."
msgstr ""

#: ../../PyMOTW/contextlib/index.rst:136
msgid "From Generator to Context Manager"
msgstr ""

#: ../../PyMOTW/contextlib/index.rst:138
msgid ""
"Creating context managers the traditional way, by writing a class with "
":func:`__enter__()` and :func:`__exit__()` methods, is not difficult. But "
"sometimes it is more overhead than you need just to manage a trivial bit of "
"context. In those sorts of situations, you can use the "
":func:`contextmanager()` decorator to convert a generator function into a "
"context manager."
msgstr ""

#: ../../PyMOTW/contextlib/index.rst:149
msgid ""
"The generator should initialize the context, yield exactly one time, then "
"clean up the context. The value yielded, if any, is bound to the variable in"
" the :command:`as` clause of the :command:`with` statement. Exceptions from "
"within the :command:`with` block are re-raised inside the generator, so they"
" can be handled there."
msgstr ""

#: ../../PyMOTW/contextlib/index.rst:185
msgid "Nesting Contexts"
msgstr ""

#: ../../PyMOTW/contextlib/index.rst:187
msgid ""
"At times it is necessary to manage multiple contexts simultaneously (such as"
" when copying data between input and output file handles, for example). It "
"is possible to nest :command:`with` statements one inside another. If the "
"outer contexts do not need their own separate block, though, this adds to "
"the indention level without giving any real benefit. Using :func:`nested()` "
"nests the contexts using a single :command:`with` statement."
msgstr ""

#: ../../PyMOTW/contextlib/index.rst:199
msgid ""
"Notice that the contexts are exited in the reverse order in which they are "
"entered."
msgstr ""

#: ../../PyMOTW/contextlib/index.rst:218
msgid ""
"In Python 2.7 and later, :func:`nested` is deprecated because the "
":command:`with` statement supports nesting directly."
msgstr ""

#: ../../PyMOTW/contextlib/index.rst:225
msgid ""
"Each context manager and optional :command:`as` clause are separated by a "
"comma (``,``).  The effect is similar to using :func:`nested`, but avoids "
"some of the edge-cases around error handling that :func:`nested` could not "
"implement correctly."
msgstr ""

#: ../../PyMOTW/contextlib/index.rst:248
msgid "Closing Open Handles"
msgstr ""

#: ../../PyMOTW/contextlib/index.rst:250
msgid ""
"The :class:`file` class supports the context manager API directly, but some "
"other objects that represent open handles do not. The example given in the "
"standard library documentation for :mod:`contextlib` is the object returned "
"from :func:`urllib.urlopen`.  There are other legacy classes that use a "
":func:`close` method but do not support the context manager API. To ensure "
"that a handle is closed, use :func:`closing()` to create a context manager "
"for it."
msgstr ""

#: ../../PyMOTW/contextlib/index.rst:262
msgid ""
"The handle is closed whether there is an error in the :command:`with` block "
"or not."
msgstr ""

#: ../../PyMOTW/contextlib/index.rst:289
msgid "`contextlib <http://docs.python.org/library/contextlib.html>`_"
msgstr ""

#: ../../PyMOTW/contextlib/index.rst:289
msgid "The standard library documentation for this module."
msgstr ""

#: ../../PyMOTW/contextlib/index.rst:292
msgid ":pep:`343`"
msgstr ""

#: ../../PyMOTW/contextlib/index.rst:292
msgid "The :command:`with` statement."
msgstr ""

#: ../../PyMOTW/contextlib/index.rst:295
msgid ""
"`Context Manager Types "
"<http://docs.python.org/library/stdtypes.html#typecontextmanager>`__"
msgstr ""

#: ../../PyMOTW/contextlib/index.rst:295
msgid ""
"Description of the context manager API from the standard library "
"documentation."
msgstr ""

#: ../../PyMOTW/contextlib/index.rst:297
msgid ""
"`With Statement Context Managers "
"<http://docs.python.org/reference/datamodel.html#context-managers>`__"
msgstr ""

#: ../../PyMOTW/contextlib/index.rst:298
msgid ""
"Description of the context manager API from the Python Reference Guide."
msgstr ""
